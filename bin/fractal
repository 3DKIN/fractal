#!/usr/bin/env node

const local = require('../.');
const Liftoff = require('liftoff');
const utils = require('@frctl/utils');
const semver = require('semver');
let yargs = require('yargs');
// const yargonaut = require('yargonaut').style('cyan').errorsStyle('red.bold');
const handler = require('../src/cli/handler');
const output = require('../src/cli/ui');

const cli = new Liftoff({
  name: 'fractal',
  processTitle: 'fractal',
  moduleName: '@frctl/fractal',
  configName: 'fractal.config',
  extensions: {
    '.js': null,
    '.json': null
  }
});

cli.launch({}, function(env) {

  const ui = output();
  const format = ui.utils.format;

  /**
   * Get or create Fractal instance
   */

  let app;
  const config = env.configPath ? require(env.configPath) : {};

  env.scope = Boolean(env.configPath) ? 'project' : 'global';

  if (config instanceof local.Fractal || (config.constructor && config.constructor.name === 'Fractal')) {
    app = config;
  } else {
    const frctl = env.modulePath ? require(env.modulePath) : local;
    app = frctl(config);
  }

  if (semver.major(app.version) < 2) {
    app.cli.exec();
    return;
  }

  /**
   * Configure args parser/handler
   */

  yargs.usage(format(`\n$0 <command> [...]`, 'yellow.bold'))
    .help('help', 'show help information')
    .option('debug', {
      describe: 'show debug output',
      global: true,
      boolean: true
    })
    .option('version', {
      describe: 'display version information',
      global: false,
      boolean: true
    });

  /**
   * Default command
   */

  yargs.command('*', 'Fractal info', {}, argv => {
    const isError = argv._.length > 0;
    ui.br();
    if (isError) {
      ui.error(`Command '${argv._[0]}' not recognised`);
    } else {
      ui.line().br().message(`Fractal ${format(`v${app.version}`, 'dim')}`).br();
      ui.message(`Use ${format(`${argv.$0} --help`, 'cyan')} for usage information`).br().line();
    }
    ui.br();
  });

  /**
   * Load commands, filter out those that do not match the current scope
   */

  const commands = app.commands.filter(command => {
    let scope = utils.toArray(command.opts.scope || 'project');
    return scope.includes(env.scope) || scope.includes('*');
  });

  for (const c of commands) {
    let options = {};
    if (typeof c.opts.options === 'function') {
      options = c.opts.options;
    } else {
      options = yargs => {
        yargs.reset()
          .usage(format(`\n$0 ${c.command}`, 'yellow.bold'))
          .options(c.opts.options || {})
      };
    }
    yargs.command(
      c.command,
      c.description,
      options,
      handler(c.opts, c.handler, app, env, yargs)
    );
  }

  /**
   * Parse argv to trigger appropriate command
   */

  return yargs.argv;

});
